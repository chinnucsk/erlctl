Problem
=======

One drawback of Erlang is that it is just so flexible.  While this is good
for a coder that needs a powerful environment, it generates unwanted
operational load for those who have to deploy applications.  Recently, there
has been a movement among operations-concerned developers towards convention-
over-configuration as a way to manage this complexity.  erlctl is an attempt
to bring these benefits to the deployment and management of Erlang
applications.

Best Practices
==============

After a survey of major Erlang applications, the consensus seems to be that
the node should be named the same as the application for the common case of
deploying one copy of an application at a node.  Usually an option is provided
to indicate if another node is to be managed.

Distributed Erlang is usually used to communicate commands to a running node.
Most applications seem to use the Erlang convention of using $HOME to find a
cookie file for authentication.

Some applications use Unix symlinks to allow one program to serve multiple
purposes.  Examples include bzip2, lzma, busybox, and mmv.

All of this is complicated by the fact that Erlang includes a powerful, but
unwieldy, application deployment paradigm.

Architecture
============

With this in mind, erlctl has been designed to give a simple, comprehensive
convention for deploying and controlling Erlang applications.  It consists of
two components: the command line tool itself, and an application to run inside
of Erlang nodes to be controlled.

Command Line Interface
======================

The format for using the erlctl command is:

  erlctl [<system options>] [<application>:]<command> [args ...]

Alternatively, the command may be linked from another name.  In this case,
the usage becomes:

  <application>[[_]ctl] [<systems options>] <command> [args ...]

The system options are:

  -h <host name of machine>
    Specifies which Erlang hostname should be used.
    Default determined using gethostbyname.
  -l | -s
    Determines whether longnames or shortnames will be used for distribution.
    Defaults to shortnames.
  -n <node to be managed>
    Specifies which Erlang node should be managed.
    Defaults to application@<hostname>
  -c <config file>
    Specifies a configuration file.  This file can be managed with the config
    commands or with your text editor of choice.
    Defaults to $HOME/.application.config

Application Interface
=====================

The erlctl application should be running in each node to be managed.  Your
application must depend on erlctl or call erlctl:start/0 if it doesn't use
the application system.  It should also call erlctl:register(appname) when it
is ready to be managed at runtime (where appname is the same atom name as your
application is named).

It should provide a module called appname_ctl.  This module should provide the
interface functions to implement various actions.  All functions should expect
three arguments: Context, Config, and Args.

When a command is executed, an Erlang node starts in the CLI command and there
may also be an Erlang node already running for that application.

Initially, a search is done for a node.  If it is found, the command is
executed first, in that node, with the context 'running'.  If no node is
found, a new one is started (detached, with no shell, daemonized), and this
function is executed in it with the context 'start'.  If the function exits
with the atom 'started', then the VM continues running.  If no function clause
matches 'start', then a function is called in the CLI VM with context 'none'.
This allows easily creating functions as appropriate for running without a
daemon, starting a daemon, and running inside of a daemon.

The config is just loaded from the configuration file.  The args are the rest
of the command line as split by your shell, as strings.

Helpful Utilities
=================

To manage the configuration file, a "config" command is provided.  This 
command modifies the config file as a bag of key-value pairs.  No locking is
performed on the file, although it is atomically updated via symlink swaps on
systems that support it.

Config values can optionally specify a type.  Once a type is specified, an
update that changes the type of a value is not allowed (although the value 
may be deleted and recreated as separate entries).  The special type 'any'
allows any type of data to be set.  Also, all types support a 'null' value.
This can be used when initializing a configuration to provide type-safety
for configuration values while not specifying defaults.

To display output at the CLI node (correctly in any context), erlctl provides
a format/2 function (which is identical to io:format/2).

To set exit codes at the CLI node (correctly in any context), erlctl provides
a halt/1 function.

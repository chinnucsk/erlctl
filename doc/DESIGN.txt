Problem
=======

One drawback of Erlang is that it is just so flexible.  While this is good
for a coder that needs a powerful environment, it generates unwanted
operational load for those who have to deploy applications.  Recently, there
has been a movement among operations-concerned developers towards convention-
over-configuration as a way to manage this complexity.  erlctl is an attempt
to bring these benefits to the deployment and management of Erlang
applications.

Best Practices
==============

After a survey of major Erlang applications, the consensus seems to be that
the node should be named the same as the application for the common case of
deploying one copy of an application at a node.  Usually an option is provided
to indicate if another node is to be managed.

Distributed Erlang is usually used to communicate commands to a running node.
Most applications seem to use the Erlang convention of using $HOME to find a
cookie file for authentication.

Some applications use Unix symlinks to allow one program to serve multiple
purposes.  Examples include bzip2, lzma, busybox, and mmv.

All of this is complicated by the fact that Erlang includes a powerful, but
unwieldy, application deployment paradigm.

Architecture
============

With this in mind, erlctl has been designed to give a simple, comprehensive
convention for deploying and controlling Erlang applications.  It consists of
two components: the command line tool itself, and an application to run inside
of Erlang nodes to be controlled.

Command Line Interface
======================

The format for using the erlctl command is:

  erlctl [<system options>] [<application>:]<command> [args ...]

Alternatively, the command may be linked from another name.  In this case,
the usage becomes:

  <application>[[_]ctl] [<systems options>] <command> [args ...]

The system options are:

  -h <host name of machine>
    Specifies which Erlang hostname should be used.
    Default determined using gethostbyname.
  -l | -s
    Determines whether longnames or shortnames will be used for distribution.
    Defaults to shortnames.
  -n <node to be managed>
    Specifies which Erlang node should be managed.
    Defaults to application@<hostname>
  -c <config file>
    Specifies a configuration file.  This file can be managed with the config
    commands or with your text editor of choice.
    Defaults to $HOME/.application.config

Application Interface
=====================

The erlctl application should be running in each node to be managed.  Your
application must depend on erlctl or call erlctl:start/0 if it doesn't use
the application system.  It should also call erlctl:register(appname) when it
is ready to be managed at runtime (where appname is the same atom name as your
application is named).

It should provide a module called appname_ctl.  This module should provide the
interface functions to implement various actions.  All functions should expect
three arguments: Context, Config, and Args.

When a command is executed, an Erlang node starts in the CLI command and there
may also be an Erlang node already running for that application.

The correct command implementation function is executed based on the context
and the system state. If you provide the correct commands, most use-cases
should be manageable. For commands that should always just be executed in the
CLI process, the 'none' context is provided. For commands that should be
executed in a running server context, the 'running' context is there. To
provide fallback behavior for commands in the 'running' context, there is a
'not_running' context. Finally, for the case where a node should be started,
there is a 'start' context.

The return value of command implementation functions is not examined, and
returning without an exception is consider success. If they raise an
exception, the command-line utility exits with a status of 254. If they are
not found, certain fall-through behavior happens, as specified in the next
section. If you wish to manipulate configuration data, do input or output, or
exit with a status code, various mechanisms are provided, as detailed in the
final section.

The config is just loaded from the configuration file.  The args are the rest
of the command line as split by your shell, as strings.

Context Selection
=================

The process for selecting Context has a fair bit of voodoo to achieve the
behavior that I feel is useful.  Roughly, the following pseudo-code is
followed, and terminates as soon as an attempted command exists:

try none:command(...)          [in CLI Node]
find_node                      [in CLI Node]
if node is running:            [in CLI Node]
  try running:command(...)     [in Target Node]
else:
  try not_running:command(...) [in CLI Node]
  try start:command(...)       [in Newly Started Node]

Essentially, 'none' commands override everything, then only 'running' commands
when a node is running, OR 'not_running' in preference to 'start'.

The idea is that the normal case is to either run commands with no context
(usually utility commands) or commands in the server process.  Fallback
behavior is provided by "not running" cases, with "start" commands as the last
resort when no node is running.  This "start" behavior is designed to make it
difficult to accidentally start multiple copies of a server when you instead
intend to have graceful startup for certain commands that are normally used
when a server is running.

Helpful Utilities
=================

To manage the configuration file, a "config" command is provided.  This 
command modifies the config file as a bag of key-value pairs.  No locking is
performed on the file, although it is atomically updated via symlink swaps on
systems that support it.

Config values can optionally specify a type.  Once a type is specified, an
update that changes the type of a value is not allowed (although the value 
may be deleted and recreated as separate entries).  The special type 'any'
allows any type of data to be set.  Also, all types support a 'null' value.
This can be used when initializing a configuration to provide type-safety
for configuration values while not specifying defaults.

To display output at the CLI node (correctly in any context), erlctl provides
a format/2 function (which is identical to io:format/2).

To set exit codes at the CLI node (correctly in any context), erlctl provides
a halt/1 function.
